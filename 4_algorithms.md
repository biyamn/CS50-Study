# 1) 검색 알고리즘
주어진 배열 속에서 특정 값을 찾는 방법을 알아보자. 

## (1) 선형 탐색
숫자들이 정렬되어있지 않을 때, 숫자 50을 찾는 방법은 처음부터 끝까지 열어보는 수밖에 없다. 
```
# 배열의 인덱스를 처음부터 끝까지 증가시키면서 방문하여 그 값이 속하는지 확인

For i from 0 to n–1

    If i'th element is 50

        Return true
# 없으면 false를 리턴함
Return false
```
<br>

## (2) 이진 탐색
배열이 정렬되어 있을 때, 반으로 갈라서 수를 탐색한다. 
```
# 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰 (큰 값이 저장되어 있는) 인덱스로 이동을 반복함

If no items

    Return false

If middle item is 50

    Return true

Else if 50 < middle item

    Search left half

Else if 50 > middle item

    Search right half
```

<br>

### 💡생각해보기
Q. 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까요 이진 검색이 빠를까요?

A. 똑같을 것 같다. 정렬되지 않은 배열이라면 똑같이 무작위일 것 같기 때문이다. 

<br>

# 2) 알고리즘 표기법
특정 알고리즘을 작성하였을 때 그 실행 시간을 표기하는 방법을 배워보자.
(프로그램을 작성한 후에 실행하면 작업이 완료될때까지 어느정도 시간이 소요된다. 아주 간단한 프로그램인 경우에는 실행 시간을 걱정할 필요가 없지만, 처리하는 데이터가 많아지고 처리하는 작업이 복잡해질수록 실행 시간은 매우 중요해진다.)

## Big-O 표기법(중요)
알고리즘의 효율성을 말할 때 Big-O 표기법을 사용한다.
(여기서 O는 "on the order of"의 약자로, "~만큼의 정도로 커지는"이라고 해석할 수 있다. )
알고리즘을 수행할 때 <b>최악의 경우</b>에 필요한 시간의 상한선을 의미한다.

- O(n^2)
- O(n log n)
- O(n) - 선형 검색
- O(log n) - 이진 검색
- O(1)

## Omega 표기법
Big-O 표기법과 반대로 알고리즘을 수행할 때 <b>최상의 경우</b>에 필요한 시간을 나타낼 수 있다. 

- Ω(n^2)
- Ω(n log n)
- Ω(log n)
- Ω(1) - 선형 탐색, 이진 탐색(운이 좋으면 바로 찾을 수 있기 때문)

<br>

### 💡생각해보기
Q. 실행시간의 상한이 낮은 알고리즘이 더 좋을까요, 하한이 낮은 알고리즘이 더 좋을까요?

A. 실행시간의 상한이 낮은 알고리즘이 더 좋을 것 같다. 알고리즘을 짤 때는 최악의 상황을 고려해야 하기 때문에 하한보다는 상한을 더 고려해야 하기 때문이다. 