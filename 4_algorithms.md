# 1) 검색 알고리즘
주어진 배열 속에서 특정 값을 찾는 방법을 알아보자. 

## (1) 선형 탐색
- 숫자들이 정렬되어있지 않을 때, 숫자 50을 찾는 방법은 처음부터 끝까지 열어보는 수밖에 없다. 
- 시간 복잡도는 O(n)

```
# 배열의 인덱스를 처음부터 끝까지 증가시키면서 방문하여 그 값이 속하는지 확인

For i from 0 to n–1

    If i'th element is 50

        Return true
# 없으면 false를 리턴함
Return false
```
<br>

<hr>

<br>

## (2) 이진 탐색
배열이 정렬되어 있을 때, 반으로 갈라서 수를 탐색한다. 
```
# 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스 또는 큰 (큰 값이 저장되어 있는) 인덱스로 이동을 반복함

If no items

    Return false

If middle item is 50

    Return true

Else if 50 < middle item

    Search left half

Else if 50 > middle item

    Search right half
```

<br>

### 💡생각해보기
Q. 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까요 이진 검색이 빠를까요?

A. 똑같을 것 같다. 정렬되지 않은 배열이라면 똑같이 무작위일 것 같기 때문이다. 

<br>

<hr>

<br>

# 2) 알고리즘 표기법
특정 알고리즘을 작성하였을 때 그 실행 시간을 표기하는 방법을 배워보자.
(프로그램을 작성한 후에 실행하면 작업이 완료될때까지 어느정도 시간이 소요된다. 아주 간단한 프로그램인 경우에는 실행 시간을 걱정할 필요가 없지만, 처리하는 데이터가 많아지고 처리하는 작업이 복잡해질수록 실행 시간은 매우 중요해진다.)

## Big-O 표기법(중요)
알고리즘의 효율성을 말할 때 Big-O 표기법을 사용한다.
(여기서 O는 "on the order of"의 약자로, "~만큼의 정도로 커지는"이라고 해석할 수 있다. )
알고리즘을 수행할 때 <b>최악의 경우</b>에 필요한 시간의 상한선을 의미한다.

- O(n^2)
- O(n log n)
- O(n) - 선형 검색
- O(log n) - 이진 검색
- O(1)

## Omega 표기법
Big-O 표기법과 반대로 알고리즘을 수행할 때 <b>최상의 경우</b>에 필요한 시간을 나타낼 수 있다. 

- Ω(n^2)
- Ω(n log n)
- Ω(log n)
- Ω(1) - 선형 탐색, 이진 탐색(운이 좋으면 바로 찾을 수 있기 때문)

<br>

### 💡생각해보기
Q. 실행시간의 상한이 낮은 알고리즘이 더 좋을까요, 하한이 낮은 알고리즘이 더 좋을까요?

A. 실행시간의 상한이 낮은 알고리즘이 더 좋을 것 같다. 알고리즘을 짤 때는 최악의 상황을 고려해야 하기 때문에 하한보다는 상한을 더 고려해야 하기 때문이다. 

<br>

<hr>

<br>

# 3) 선형 검색
- 선형 검색은 원하는 원소가 발견될 때까지 <b>처음부터 마지막 자료까지</b> 순서대로 검색한다. 
- 정확하지만 아주 효율적이지 못한 방법
- <b>자료가 정렬되어 있지 않거나</b> 어떤 정보도 없이 하나씩 찾아야 하는 경우에 유용
- 선형 검색의 시간복잡도는 <b>O(n)</b>

## 선형 검색의 예
### (1) 숫자로 이루어진 배열에서 선형 검색하기
- 숫자로 이루어진 배열 numbers에서 50을 찾는 과정

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

### (2) 문자열로 이루어진 배열에서 선형 검색하기 - 전화번호부
- names 배열과 numbers 배열을 따로 정의하고 names 배열에서 검색을 해서 해당하는 인덱스의 numbers 배열 값을 출력

- 하지만 이 경우에는 names 배열과 numbers 배열이 서로 같은 인덱스를 가져야 한다는 한계가 있다.

```c
#include <stdio.h>
#include <cs50.h>
#include <string.h>

int main(void)
{
    string names[4] = {"A", "B", "C", "D"};
    string numbers[4] = {"111-222-2222", "4444-3333-2222", "1234-3434-2422", "9099-9999-3333"};
    
    for (int i=0; i<4; i++)
    {
        if (strcmp(names[i], "A") == 0)
        {
            printf("%s\n", numbers[i]);
            // 관례적으로 성공적 반환은 0 리턴 
            return 0;
        }
    }
    printf("Not found\n");
    // 관례적으로 다른 값 혹은 에러가 나면 1 리턴
    return 1;
}
```

### (3) 구조체 정의하기 - 전화번호부
- person이라는 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언하고 `.`로 그 안의 속성값에 접근한다. 

- `person people[4];`가 있다면 person.name과 person.number가 각각 이름과 전화번호를 저장하는 변수가 된다.

```c
#include <stdio.h>
#include <cs50.h>
#include <string.h>

// 여러가지 자료형을 위한 그릇
// 캡슐화
typedef struct
{
    string name;
    string number;
}
person;

int main(void)
{
    person people[4];

    people[0].name = "A";
    people[0].number = "111-222-2222";

    people[1].name  = "B";
    people[1].number = "4444-3333-2222";

    people[2].name  = "C";
    people[2].number = "1234-3434-2422";

    people[3].name  = "D";
    people[3].number = "9099-9999-3333";

    // "A" 전화번호 검색
    for (int i=0; i<4; i++)
    {
        if (strcmp(people[i].name, "A") == 0)
        {
            printf("%s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

<br>

### 💡생각해보기
Q. 전화번호부와 같이 구조체를 정의하여 관리 및 검색을 하면 더 편리한 예는 또 무엇이 있을까요?

A. 주소, 학번, 성적 등

<br>

<hr>

<br>

# 4) 버블 정렬
- 선형 탐색과 같이 정렬되지 않은 리스트를 탐색하는 것보다 정렬한 뒤 탐색하는 것이 더 효율적이다. 
- 버블 정렬은 정렬 알고리즘이다. 
- 버블 정렬은 <b>두 개의 인접한 자료 값을 비교</b>하면서 위치를 교환하는 방식이다.(쌍을 이뤄 앞뒤 순서를 교환한다)
- 버블 정렬의 시간복잡도는 <b>O(n^2)</b>

## 의사코드
```
// 전체가 n명이면 n-1번 비교 가능(n-1)
Repeat n–1 times
    // 첫번째 사람을 0이라고 하고 n-2번까지 반복(n-1)
    For i from 0 to n–2
        // 그 자리와 오른쪽을 비교하여 크면
        If i'th and i+1'th elements out of order
            // 바꿈
            Swap them
```

## 버블 정렬의 시간복잡도
- 시간 상한선(Big-O): (n-1)*(n-1) -> O(n^2)
- 시간 하한선(Omega): (n-1)*(n-1) -> O(n^2)(정렬된 배열이 들어와도 같은 횟수를 반복함)

<br>

### 💡생각해보기
Q. 버블 정렬이 효율적인 경우는 어떤 경우인가요? 반대로 어떤 경우에 비효율적이게 될까요? 

A. 
(1) 효율적인 경우: 뒤죽박죽 섞인 경우
(2) 비효율적인 경우: 이미 정렬된 경우, 혹은 정렬이 거의 끝난 경우(프로그램은 정렬되어 있는지 알지 못한 채로 버블 정렬을 진행하므로)

<br>

<hr>

<br>

# 5) 선택 정렬
- 처음부터 끝까지 탐색하며 가장 작은 숫자를 선택하고 그걸 가장 왼편에 위치시킨다.
- 매번 목표를 세워 가장 작은 값을 찾고 다음 작은 값을 찾는다.(번복할 때마다 다음으로 가장 작은 수를 고른다)

## 의사코드
```
// n번 반복한다
For i from 0 to n–1
    // i번째부터 마지막 항목 중 가장 작은 값을 찾는다
    Find smallest item between i'th item and last item
    // 제일 작은 값을 찾을 때마다 집어서 위치를 바꾼다
    Swap smallest item with i'th item
```

## 선택 정렬의 시간복잡도
- 시간 상한선(Big-O): n + (n-1) + (n-2) + ... + 1 -> n(n+1)/2 -> O(n^2)
- 시간 하한선(Omega): O(n^2)(프로그램은 배열 속 다른 값을 전부 보기 전까지 알 수 없으므로)

<br>

### 💡생각해보기
Q. 선택정렬을 좀 더 효율적으로 어떻게 바꿀 수 있을까요?
A. 잘 모르겠다. 알게 되면 추가하자

<br>

<hr>

<br>

# 6) 정렬 알고리즘의 실행시간
## 여태까지 배운 정렬 알고리즘의 실행시간
(1) 실행시간의 상한
- O(n^2): 선택 정렬, 버블 정렬
- O(n log n)
- O(n): 선형 검색
- O(log n): 이진 검색
- O(1)

(2) 실행시간의 하한
- Ω(n^2): 선택 정렬, 버블 정렬
- Ω(n log n)
- Ω(n)
- Ω(log n)
- Ω(1): 선형 검색, 이진 검색

## 버블 정렬의 실행시간 줄이기
- 버블 정렬은 원래 리스트가 모두 정렬되어 있더라도 실행시간의 하한이 Ω(n^2)였다. 
- 하지만 교환이 없을 때 알고리즘을 일찍 종료한다면 정렬된 리스트에서는 n-1번만 비교하면 될 것이다. 이렇게 되면 실행 시간의 하한은 Ω(n)이 된다.

<br>

### 💡생각해보기
Q. 선택 정렬의 실행 시간의 하한도 버블 정렬처럼 더 단축시킬 수 있을까요?
A. 
선택 정렬의 동작 원리는 다음과 같다.
- 처음부터 끝까지 탐색하며 가장 작은 숫자를 선택하고 그걸 가장 왼편에 위치시킨다.
- 매번 목표를 세워 가장 작은 값을 찾고 다음 작은 값을 찾는다.(번복할 때마다 다음으로 가장 작은 수를 고른다)
이렇듯 모든 요소를 확인하기 때문에 하한을 줄이기 어려울 것 같다.
하지만 만약 방안이 있어 알게되면 이곳에 추가할 것이다. 

<br>

<hr>

<br>

# 7) 재귀
- <b>함수가 본인 스스로를 호출</b>해서 사용하는 것을 재귀라고 한다.

## (1) 일반 탑쌓기 코드
```c
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}

void draw(int h)
{
    for (int i=1; i<=h; i++)
    {
        for (int j=1; j<=i; j++)
        {
            printf("#");
        }
        printf("\n");
    }
}
```

## (2) 재귀를 이용한 탑쌓기 코드
- 4층짜리 탑은 높이 3의 탑에 한 줄을 더한 거다.
- 3층짜리 탑은 높이 2의 탑에 한 줄을 더한 거다.
- 2층짜리 탑은 높이 1의 탑에 한 줄을 더한 거다. 
- 하지만 1층짜리 탑은 0층짜리 탑에 한 줄을 더한 것인데 0층짜리 탑은 뭘까? 아무것도 아님. 따라서 반환, 종료, 혹은 정지 등 알고리즘에 맞게 처리를 해야 한다. 따라서 시작점에서는 재귀적으로 자기 자신을 호출하지 않도록 특수한 처리를 해줘야 한다. 

-> 이를 재귀적 정의라고 한다.

```c
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}

void draw(int h)
{
    if (h==0)
    {
        return;
    }
    draw(h-1);

    for (int i=0;i<h;i++)
    {
        printf("#");
    }
    printf("\n");
}
```

<br>

### 💡생각해보기
Q. 반복문을 쓸 수 있는데도 재귀를 사용하는 이유는 무엇일까요?
A. 코드가 더 간결해지기 때문에

<br>

<hr>

<br>

# 8) 병합 정렬
- 버블 정렬이나 선택 정렬보다 뛰어나다(빠르다)! 
- 대표적인 '분할 정복' 방법을 채택한 알고리즘
- 무언가를 계속 절반으로 나눈다면 이는 로그 함수로 표현할 수 있다. (밑이 2인 로그이나 대략 log n이라고 한다.)
- 병합 정렬의 시간 복잡도는 n log n이다.(Omega도 동일함)
- 최악의 경우 빠르지만 최선의 경우 시간을 낭비한다.

![캡처](https://user-images.githubusercontent.com/101965666/192105521-ac33be0c-7238-460f-a7ec-bbd71d5b3368.PNG)

## 병합 정렬의 의사코드
```
If only one item
    Return
Else
    Sort left half of items
    Sort right half of items
    Merge sorted halves
```

## 시간 복잡도 비교
확실히 병합 정렬이 빠른 것을 알 수 있다. 

![캡처](https://user-images.githubusercontent.com/101965666/192105828-6a880f67-f5b4-485f-b72f-ebe765481216.PNG)

<br>

### 💡생각해보기
Q. 병합 정렬을 선택 정렬이나 버블 정렬과 비교했을 때 장점과 단점은 무엇이 있을까요?

A.
장점: 빠르다.
단점: 메모리를 더 많이 사용한다.

### 참고
분할 정렬을 잘 설명한 블로그 주소: https://blog.naver.com/ndb796/221227934987

### 정리

<img width="712" alt="images_jaeyunn_15_post_ff10da68-72c8-465e-9da8-9260b26db9a9_스크린샷 2021-03-07 오후 11 32 57" src="https://user-images.githubusercontent.com/101965666/192107149-421500e4-868a-45d7-bc63-c716a49db288.png">